// Code generated by MockGen. DO NOT EDIT.
// Source: ./provider.go
//
// Generated by this command:
//
//	mockgen -typed=true -source=./provider.go -destination=./provider_mock.go -package=component . ComponentProvider
//

// Package component is a generated GoMock package.
package component

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockComponentProvider is a mock of ComponentProvider interface.
type MockComponentProvider struct {
	ctrl     *gomock.Controller
	recorder *MockComponentProviderMockRecorder
}

// MockComponentProviderMockRecorder is the mock recorder for MockComponentProvider.
type MockComponentProviderMockRecorder struct {
	mock *MockComponentProvider
}

// NewMockComponentProvider creates a new mock instance.
func NewMockComponentProvider(ctrl *gomock.Controller) *MockComponentProvider {
	mock := &MockComponentProvider{ctrl: ctrl}
	mock.recorder = &MockComponentProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockComponentProvider) EXPECT() *MockComponentProviderMockRecorder {
	return m.recorder
}

// Activate mocks base method.
func (m *MockComponentProvider) Activate(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Activate", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Activate indicates an expected call of Activate.
func (mr *MockComponentProviderMockRecorder) Activate(ctx any) *MockComponentProviderActivateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Activate", reflect.TypeOf((*MockComponentProvider)(nil).Activate), ctx)
	return &MockComponentProviderActivateCall{Call: call}
}

// MockComponentProviderActivateCall wrap *gomock.Call
type MockComponentProviderActivateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockComponentProviderActivateCall) Return(arg0 error) *MockComponentProviderActivateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockComponentProviderActivateCall) Do(f func(context.Context) error) *MockComponentProviderActivateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockComponentProviderActivateCall) DoAndReturn(f func(context.Context) error) *MockComponentProviderActivateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Configure mocks base method.
func (m *MockComponentProvider) Configure(ctx context.Context, options ...Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Configure", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Configure indicates an expected call of Configure.
func (mr *MockComponentProviderMockRecorder) Configure(ctx any, options ...any) *MockComponentProviderConfigureCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Configure", reflect.TypeOf((*MockComponentProvider)(nil).Configure), varargs...)
	return &MockComponentProviderConfigureCall{Call: call}
}

// MockComponentProviderConfigureCall wrap *gomock.Call
type MockComponentProviderConfigureCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockComponentProviderConfigureCall) Return(arg0 error) *MockComponentProviderConfigureCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockComponentProviderConfigureCall) Do(f func(context.Context, ...Option) error) *MockComponentProviderConfigureCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockComponentProviderConfigureCall) DoAndReturn(f func(context.Context, ...Option) error) *MockComponentProviderConfigureCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Deactivate mocks base method.
func (m *MockComponentProvider) Deactivate(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deactivate", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deactivate indicates an expected call of Deactivate.
func (mr *MockComponentProviderMockRecorder) Deactivate(ctx any) *MockComponentProviderDeactivateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deactivate", reflect.TypeOf((*MockComponentProvider)(nil).Deactivate), ctx)
	return &MockComponentProviderDeactivateCall{Call: call}
}

// MockComponentProviderDeactivateCall wrap *gomock.Call
type MockComponentProviderDeactivateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockComponentProviderDeactivateCall) Return(arg0 error) *MockComponentProviderDeactivateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockComponentProviderDeactivateCall) Do(f func(context.Context) error) *MockComponentProviderDeactivateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockComponentProviderDeactivateCall) DoAndReturn(f func(context.Context) error) *MockComponentProviderDeactivateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Initialize mocks base method.
func (m *MockComponentProvider) Initialize(ctx context.Context, options ...Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Initialize", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Initialize indicates an expected call of Initialize.
func (mr *MockComponentProviderMockRecorder) Initialize(ctx any, options ...any) *MockComponentProviderInitializeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockComponentProvider)(nil).Initialize), varargs...)
	return &MockComponentProviderInitializeCall{Call: call}
}

// MockComponentProviderInitializeCall wrap *gomock.Call
type MockComponentProviderInitializeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockComponentProviderInitializeCall) Return(arg0 error) *MockComponentProviderInitializeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockComponentProviderInitializeCall) Do(f func(context.Context, ...Option) error) *MockComponentProviderInitializeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockComponentProviderInitializeCall) DoAndReturn(f func(context.Context, ...Option) error) *MockComponentProviderInitializeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Recover mocks base method.
func (m *MockComponentProvider) Recover(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recover", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Recover indicates an expected call of Recover.
func (mr *MockComponentProviderMockRecorder) Recover(ctx any) *MockComponentProviderRecoverCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recover", reflect.TypeOf((*MockComponentProvider)(nil).Recover), ctx)
	return &MockComponentProviderRecoverCall{Call: call}
}

// MockComponentProviderRecoverCall wrap *gomock.Call
type MockComponentProviderRecoverCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockComponentProviderRecoverCall) Return(arg0 error) *MockComponentProviderRecoverCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockComponentProviderRecoverCall) Do(f func(context.Context) error) *MockComponentProviderRecoverCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockComponentProviderRecoverCall) DoAndReturn(f func(context.Context) error) *MockComponentProviderRecoverCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockConfigurable is a mock of Configurable interface.
type MockConfigurable struct {
	ctrl     *gomock.Controller
	recorder *MockConfigurableMockRecorder
}

// MockConfigurableMockRecorder is the mock recorder for MockConfigurable.
type MockConfigurableMockRecorder struct {
	mock *MockConfigurable
}

// NewMockConfigurable creates a new mock instance.
func NewMockConfigurable(ctrl *gomock.Controller) *MockConfigurable {
	mock := &MockConfigurable{ctrl: ctrl}
	mock.recorder = &MockConfigurableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigurable) EXPECT() *MockConfigurableMockRecorder {
	return m.recorder
}

// Configure mocks base method.
func (m *MockConfigurable) Configure(ctx context.Context, options ...Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Configure", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Configure indicates an expected call of Configure.
func (mr *MockConfigurableMockRecorder) Configure(ctx any, options ...any) *MockConfigurableConfigureCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Configure", reflect.TypeOf((*MockConfigurable)(nil).Configure), varargs...)
	return &MockConfigurableConfigureCall{Call: call}
}

// MockConfigurableConfigureCall wrap *gomock.Call
type MockConfigurableConfigureCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigurableConfigureCall) Return(arg0 error) *MockConfigurableConfigureCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigurableConfigureCall) Do(f func(context.Context, ...Option) error) *MockConfigurableConfigureCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigurableConfigureCall) DoAndReturn(f func(context.Context, ...Option) error) *MockConfigurableConfigureCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockInitializable is a mock of Initializable interface.
type MockInitializable struct {
	ctrl     *gomock.Controller
	recorder *MockInitializableMockRecorder
}

// MockInitializableMockRecorder is the mock recorder for MockInitializable.
type MockInitializableMockRecorder struct {
	mock *MockInitializable
}

// NewMockInitializable creates a new mock instance.
func NewMockInitializable(ctrl *gomock.Controller) *MockInitializable {
	mock := &MockInitializable{ctrl: ctrl}
	mock.recorder = &MockInitializableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInitializable) EXPECT() *MockInitializableMockRecorder {
	return m.recorder
}

// Initialize mocks base method.
func (m *MockInitializable) Initialize(ctx context.Context, options ...Option) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Initialize", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Initialize indicates an expected call of Initialize.
func (mr *MockInitializableMockRecorder) Initialize(ctx any, options ...any) *MockInitializableInitializeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockInitializable)(nil).Initialize), varargs...)
	return &MockInitializableInitializeCall{Call: call}
}

// MockInitializableInitializeCall wrap *gomock.Call
type MockInitializableInitializeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInitializableInitializeCall) Return(arg0 error) *MockInitializableInitializeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInitializableInitializeCall) Do(f func(context.Context, ...Option) error) *MockInitializableInitializeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInitializableInitializeCall) DoAndReturn(f func(context.Context, ...Option) error) *MockInitializableInitializeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRecoverable is a mock of Recoverable interface.
type MockRecoverable struct {
	ctrl     *gomock.Controller
	recorder *MockRecoverableMockRecorder
}

// MockRecoverableMockRecorder is the mock recorder for MockRecoverable.
type MockRecoverableMockRecorder struct {
	mock *MockRecoverable
}

// NewMockRecoverable creates a new mock instance.
func NewMockRecoverable(ctrl *gomock.Controller) *MockRecoverable {
	mock := &MockRecoverable{ctrl: ctrl}
	mock.recorder = &MockRecoverableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRecoverable) EXPECT() *MockRecoverableMockRecorder {
	return m.recorder
}

// Recover mocks base method.
func (m *MockRecoverable) Recover(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recover", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Recover indicates an expected call of Recover.
func (mr *MockRecoverableMockRecorder) Recover(ctx any) *MockRecoverableRecoverCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recover", reflect.TypeOf((*MockRecoverable)(nil).Recover), ctx)
	return &MockRecoverableRecoverCall{Call: call}
}

// MockRecoverableRecoverCall wrap *gomock.Call
type MockRecoverableRecoverCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRecoverableRecoverCall) Return(arg0 error) *MockRecoverableRecoverCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRecoverableRecoverCall) Do(f func(context.Context) error) *MockRecoverableRecoverCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRecoverableRecoverCall) DoAndReturn(f func(context.Context) error) *MockRecoverableRecoverCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockActivatable is a mock of Activatable interface.
type MockActivatable struct {
	ctrl     *gomock.Controller
	recorder *MockActivatableMockRecorder
}

// MockActivatableMockRecorder is the mock recorder for MockActivatable.
type MockActivatableMockRecorder struct {
	mock *MockActivatable
}

// NewMockActivatable creates a new mock instance.
func NewMockActivatable(ctrl *gomock.Controller) *MockActivatable {
	mock := &MockActivatable{ctrl: ctrl}
	mock.recorder = &MockActivatableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActivatable) EXPECT() *MockActivatableMockRecorder {
	return m.recorder
}

// Activate mocks base method.
func (m *MockActivatable) Activate(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Activate", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Activate indicates an expected call of Activate.
func (mr *MockActivatableMockRecorder) Activate(ctx any) *MockActivatableActivateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Activate", reflect.TypeOf((*MockActivatable)(nil).Activate), ctx)
	return &MockActivatableActivateCall{Call: call}
}

// MockActivatableActivateCall wrap *gomock.Call
type MockActivatableActivateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockActivatableActivateCall) Return(arg0 error) *MockActivatableActivateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockActivatableActivateCall) Do(f func(context.Context) error) *MockActivatableActivateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockActivatableActivateCall) DoAndReturn(f func(context.Context) error) *MockActivatableActivateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeactivatable is a mock of Deactivatable interface.
type MockDeactivatable struct {
	ctrl     *gomock.Controller
	recorder *MockDeactivatableMockRecorder
}

// MockDeactivatableMockRecorder is the mock recorder for MockDeactivatable.
type MockDeactivatableMockRecorder struct {
	mock *MockDeactivatable
}

// NewMockDeactivatable creates a new mock instance.
func NewMockDeactivatable(ctrl *gomock.Controller) *MockDeactivatable {
	mock := &MockDeactivatable{ctrl: ctrl}
	mock.recorder = &MockDeactivatableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeactivatable) EXPECT() *MockDeactivatableMockRecorder {
	return m.recorder
}

// Deactivate mocks base method.
func (m *MockDeactivatable) Deactivate(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deactivate", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deactivate indicates an expected call of Deactivate.
func (mr *MockDeactivatableMockRecorder) Deactivate(ctx any) *MockDeactivatableDeactivateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deactivate", reflect.TypeOf((*MockDeactivatable)(nil).Deactivate), ctx)
	return &MockDeactivatableDeactivateCall{Call: call}
}

// MockDeactivatableDeactivateCall wrap *gomock.Call
type MockDeactivatableDeactivateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeactivatableDeactivateCall) Return(arg0 error) *MockDeactivatableDeactivateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeactivatableDeactivateCall) Do(f func(context.Context) error) *MockDeactivatableDeactivateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeactivatableDeactivateCall) DoAndReturn(f func(context.Context) error) *MockDeactivatableDeactivateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
