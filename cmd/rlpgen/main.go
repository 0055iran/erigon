package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/types"
	"os"

	"golang.org/x/tools/go/packages"
)

const (
	rlpPackagePath  = "github.com/erigontech/erigon-lib/rlp"
	rlpPackagePath2 = "github.com/erigontech/erigon-lib/rlp2"
)

const headerMsg = "// Code generated by rlpgen. DO NOT EDIT.\n\n"
const imports = `import (
	"io"
	"github.com/erigontech/erigon-lib/rlp"
)

`

var requiresRLP2 = false

func main() {
	// TODO(racytech): take output file name only, no need to take full path,
	// so the file will be generated in the package directory
	var (
		pkgdir   = flag.String("dir", ".", "input package")
		output   = flag.String("out", "-", "output file (default is stdout)")
		typename = flag.String("type", "", "type to generate methods for")
	)
	flag.Parse()
	// fmt.Println("pkgdir: ", *pkgdir)
	// fmt.Println("output: ", *output)
	// fmt.Println("typename: ", *typename)
	// fmt.Println("-----------------------")
	pcfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes,
		Dir:  *pkgdir,
	}
	ps, err := packages.Load(pcfg, rlpPackagePath, ".")
	if err != nil {
		_exit(fmt.Sprint("error loading package: ", err))
	}
	if len(ps) != 2 {
		_exit(fmt.Sprintf("expected to load 2 packages: 1) %v, 2) %v\n \tgot %v", rlpPackagePath, *pkgdir, len(ps)))
	}

	if err := checkPackageErrors(ps[0]); err != nil {
		_exit(err.Error())
	}
	if err := checkPackageErrors(ps[1]); err != nil {
		_exit(err.Error())
	}
	if ps[0].PkgPath != rlpPackagePath {
		_exit(fmt.Sprintf("expected first package to be %s\n", rlpPackagePath))
	}
	// TODO(racytech): add error checks for the possible unhandled errors

	var code bytes.Buffer
	// ps[0].Types - rlp package
	// ps[1].Types - package where to search for to-be generated struct
	if err := process(ps[0].Types, ps[1].Types, typename, &code); err != nil {
		_exit(err.Error())
	}

	if *output == "-" {
		os.Stdout.Write(code.Bytes())
	} else if err := os.WriteFile(*output, code.Bytes(), 0600); err != nil {
		_exit(err.Error())
	}
}

func _exit(msg string) {
	fmt.Println(msg)
	os.Exit(1)
}

func checkPackageErrors(pkg *packages.Package) error {
	var b bytes.Buffer
	if len(pkg.Errors) > 0 {
		fmt.Fprintf(&b, "package %s has errors: \n", pkg.PkgPath)
		for _, e := range pkg.Errors {
			fmt.Fprintf(&b, "%s\n", e.Msg)
		}
	}
	if b.Len() > 0 {
		return fmt.Errorf(b.String())
	}
	return nil
}

func process(pkgRLP *types.Package, pkgSrc *types.Package, typename *string, b *bytes.Buffer) error {
	// TODO(racytech): handle all possible errors

	// 1. search for a struct
	typ, err := findType(pkgSrc.Scope(), typename)
	if err != nil {
		return err
	}

	// 2. add header msg and package imports
	fmt.Fprint(b, headerMsg)
	fmt.Fprintf(b, "package %s\n\n", pkgSrc.Name())
	fmt.Fprint(b, imports)

	// 3. start EncodingSize method on a struct
	fmt.Fprintf(b, "func (obj *%s) EncodingSize2() (size int) {\n", typ.Obj().Name())

	// 4. add encoding size for every field in a struct
	addRlpEncodingSizes(b, typ)

	// 5. end EncodingSize method
	fmt.Fprintf(b, "    return\n}\n\n")

	// 6. start EncodeELP method
	fmt.Fprintf(b, "func (obj *%s) EncodeRLP2(w io.Writer) error {\n", typ.Obj().Name())

	// 7. add [32]byte
	fmt.Fprintf(b, "    var b [32]byte\n")

	// 8. encode fields of a struct
	addRlpEncodings(b, typ)

	// 9. end EncodeRLP method
	fmt.Fprintf(b, "    return nil\n}")

	// fmt.Println(b.String())

	return nil
}

func findType(scope *types.Scope, typename *string) (*types.Named, error) {
	obj := scope.Lookup(*typename)
	if obj == nil {
		return nil, fmt.Errorf("no such identifier: %s", *typename)
	}
	typ, ok := obj.(*types.TypeName)
	if !ok {
		return nil, errors.New("not a type")
	}
	named := typ.Type().(*types.Named)
	_, ok = named.Underlying().(*types.Struct)
	if !ok {
		return nil, errors.New("not a struct type")
	}
	return named, nil
}

func addRlpEncodingSizes(b *bytes.Buffer, typ *types.Named) {
	_struct := typ.Underlying().(*types.Struct)
	for i := 0; i < _struct.NumFields(); i++ {
		matchTypeToEncodingSize(b, _struct.Field(i).Type().Underlying(), _struct.Field(i).Name(), _struct.Tag(i))
	}
}

func addRlpEncodings(b *bytes.Buffer, typ *types.Named) {
	fmt.Fprintf(b, "    if err := rlp.EncodeStructSizePrefix(obj.EncodingSize2(), w, b[:]); err != nil {\n")
	fmt.Fprintf(b, "        return err\n")
	fmt.Fprintf(b, "    }\n")
	_struct := typ.Underlying().(*types.Struct)
	for i := 0; i < _struct.NumFields(); i++ {
		matchTypeToRlpEncoding(b, _struct.Field(i).Type().Underlying(), _struct.Field(i).Name(), _struct.Tag(i))
	}
}
