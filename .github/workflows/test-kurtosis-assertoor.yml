name: Kurtosis Assertoor GitHub Action

env:
  APPLICATION: "erigon"
  BUILDER_IMAGE: "golang:1.22-bookworm"
  APP_REPO: "erigontech/erigon"
  PACKAGE: "github.com/erigontech/erigon"
  TARGET_BASE_IMAGE: "debian:12.7-slim"
  LABEL_DESCRIPTION: "[docker image built on a last commit id from the ref branch] Erigon is an implementation of Ethereum (execution layer with embeddable consensus layer), on the efficiency frontier. Archive Node by default."
  KEEP_IMAGES: 100

on:
  push:
    branches:
      - 'release/2.61'
    paths-ignore:
      - '.github/**'
  workflow_dispatch:

jobs:
  define_matrix:
    runs-on: ubuntu-latest
    outputs:
      os: ${{ steps.os.outputs.os }}

    steps:
     - name: Define os
       id: os
       run: echo 'os=ubuntu-latest' >> "$GITHUB_OUTPUT"

  Build_and_test:
    needs: define_matrix
    runs-on: ${{ needs.define_matrix.outputs.os }}

    steps:
      - name: Fast checkout git repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 ## 4.1.7 release
        with:
          repository: ${{ env.APP_REPO }}
          fetch-depth: 1
          ref: ${{ github.ref_name }}
          path: 'erigon'

      - name: Setup go env and cache
        uses: actions/setup-go@v5
        with:
          go-version: '>=1.22'
          go-version-file: 'erigon/go.mod'
          cache-dependency-path: |
            erigon/go.sum

      - name: Get commit id
        id: getCommitId
        run: |
          cd erigon
          echo "id=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "short_commit_id=$(git rev-parse --short=7 HEAD)" >> $GITHUB_OUTPUT
          echo "week_of_the_year=$(/bin/date -u "+%Y-%W")" >> $GITHUB_OUTPUT
          cd ..

      - name: Set up QEMU
        uses: docker/setup-qemu-action@49b3bc8e6bdd4a60e6116a5414239cba5943d3cf ## v3.2.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@988b5a0280414f521da01fcc63a27aeeb4b104db ## v3.6.1

      - name: Setup GO build and pkg cache for one week only
        id: cache
        uses: actions/cache@v4
        with:
          key: cache-year-week-${{ steps.getCommitId.outputs.week_of_the_year }}-go.mod-hash:${{ hashFiles('erigon/go.mod') }}
          path: |
            ~/go/pkg
            ~/.cache

      # Runs a Docker container for compiling Erigon for the Linux/amd64 architecture
      # docker run --platform linux/amd64
      # # Automatically removes the container upon completion
      # --rm
      # # Mounts the 'erigon' directory from the Git repository into the container in read-only mode
      # -v $(pwd)/erigon:/erigon:ro
      # # Mounts a directory in the GitHub Actions workspace to collect the compilation output files
      # -v ${GITHUB_WORKSPACE}/build-amd64:/erigon-build
      # # Mounts the host system cache inside the container to improve compilation performance
      # -v ${HOME}/.cache:/root/.cache
      # # Mounts the Go dependencies cache inside the container
      # -v ${HOME}/go/pkg/mod:/go/pkg/mod
      # # Sets the working directory inside the container
      # -w /erigon --entrypoint /bin/bash
      # # Uses the Docker image defined in the BUILDER_IMAGE environment variable (in this case "golang:1.22-bookworm")
      # ${{ env.BUILDER_IMAGE }}
      # -c "
      # # Configures Git to allow modifying files in the '/erigon' directory
      # git config --global --add safe.directory /erigon;
      # # Compiles the various Erigon components for the amd64 architecture
      # make GOARCH=amd64 GOAMD64=v1 GOBIN=/erigon-build BUILD_TAGS=nosqlite,noboltdb 
      # erigon downloader devnet evm caplin diag integration rpcdaemon sentry txpool;
      # # Manually installs the libsilkworm_capi.so library required by Erigon
      # find / -name libsilkworm_capi.so -exec install {} /erigon-build \;"
      - name: Build for linux/amd64
        run: >
          docker run --platform linux/amd64
          --rm
          -v $(pwd)/erigon:/erigon:ro
          -v ${GITHUB_WORKSPACE}/build-amd64:/erigon-build
          -v ${HOME}/.cache:/root/.cache
          -v ${HOME}/go/pkg/mod:/go/pkg/mod
          -w /erigon --entrypoint /bin/bash
          ${{ env.BUILDER_IMAGE }}
          -c "
          git config --global --add safe.directory /erigon;
          make GOARCH=amd64 GOAMD64=v1 GOBIN=/erigon-build BUILD_TAGS=nosqlite,noboltdb 
          erigon downloader devnet evm caplin diag integration rpcdaemon sentry txpool;
          find / -name libsilkworm_capi.so -exec install {} /erigon-build \;"

      - name: Create archives and checksums
        env:
          RELEASE_VERSION: "local-${{ steps.getCommitId.outputs.short_commit_id }}"
        run: |
          cd ${GITHUB_WORKSPACE}
          mkdir $GITHUB_WORKSPACE/release
          for dir in build-*; do
            cd $dir
            echo Current directory is $(pwd). Checksum file and archive will be created for this directory
            tar czvf $GITHUB_WORKSPACE/release/${APPLICATION}_${RELEASE_VERSION}_linux_$(echo $dir | sed 's,build-,,').tar.gz \
              --transform "s,^./,${APPLICATION}_${RELEASE_VERSION}_linux_$(echo $dir | sed 's,build-,,')/," .
            cd -
          done
          cd $GITHUB_WORKSPACE/release
          sha256sum * > ${APPLICATION}_${RELEASE_VERSION}_checksums.txt
          echo Content of release directory:
          find . -type f -ls
          
      - name: Build multi-platform docker image based on the commit id ${{ steps.getCommitId.outputs.short_commit_id }} in the ref branch
        env:
          BUILD_VERSION: "local-${{ steps.getCommitId.outputs.short_commit_id }}"
          DOCKERFILE_PATH: Dockerfile.release
        run: |
            cd ${GITHUB_WORKSPACE}/release
            echo "Current directory is $(pwd) ."
            docker build \
            --file ${{ github.workspace }}/erigon/${{ env.DOCKERFILE_PATH }} \
            --build-arg RELEASE_DOCKER_BASE_IMAGE=${{ env.TARGET_BASE_IMAGE }} \
            --build-arg VERSION=${{ env.BUILD_VERSION }} \
            --build-arg APPLICATION=${{ env.APPLICATION }} \
            --tag ${{ env.APPLICATION }}:${{ env.BUILD_VERSION }} \
            --tag ${{ env.APPLICATION }}:latest \
            --tag ${{ env.APPLICATION }} \
            --target release .
      
      - name: Cleanup some space
        run: |
          df -h
          sudo rm -drf \
            /usr/share/dotnet \
            /usr/share/swift \
            /usr/local/julia* \
            /opt/google/chrome \
            /opt/microsoft/msedge \
            /opt/microsoft/powershell \
            /usr/lib/mono \
            /usr/local/lib/android \
            /usr/local/share/chromium 
          echo DEBUG current list of docker images
          docker image ls
          echo DEBUG Removing legacy node:1 matching docker images
          sudo docker image rm $(docker image ls --filter=reference='node:1*' -q)
          echo DEBUG new disk free output
          df -h

      - name: Install dependencies on Linux
        if: runner.os == 'Linux'
        run: sudo apt update && sudo apt install build-essential

      - name: download kurtosis config - with pectra
        env:
          BUILD_VERSION: local-${{ steps.getCommitId.outputs.short_commit_id }}
        # TODO: update the path to the config file with main branch before PR is merged
        run: |
          wget -O kurtosis_config_with_p.yaml https://raw.githubusercontent.com/erigontech/erigon/feat/assertor-testing/.github/workflows/kurtosis/config-pectra.properties
          sed 's#<<ERIGON_IMAGE_PLACEHOLDER>>#${{ env.APPLICATION }}:${{ env.BUILD_VERSION }}#g' kurtosis_config_with_p.yaml > kurtosis_config.yaml

      - name: Create logs directory
        run: mkdir -p logs

      - name: Run Kurtosis + assertoor tests
        id: kurtosis-test
        continue-on-error: true
        uses: ethpandaops/kurtosis-assertoor-github-action@v1
        with:
            enclave_name: "kurtosis-run-${{ github.run_id }}"
            ethereum_package_args: "./kurtosis_config.yaml"
            #kurtosis_extra_args: --verbosity detailed --cli-log-level trace
            enclave_dump: false

      - name: Parse and Format Test Details
        if: steps.kurtosis-test.outcome == 'failure'
        run: |
          mkdir -p logs
          python3 - << EOF
          import json
          import re

          def format_test_details(details):
              lines = details.split('\n')
              formatted_lines = []
              for line in lines:
                  # Parse the line
                  match = re.match(r'\s*(\d+)\s*\t(.*)\t(.*)\t(.*)\t(.*)', line)
                  if match:
                      index, complete_status, test_status, task_id, task_description = match.groups()
                      
                      # Color-code status
                      if test_status == '\u001b[0;32msuccess\u001b[0m':
                          status_color = 'GREEN ✓'
                      elif test_status == '\u001b[0;31mfailure\u001b[0m':
                          status_color = 'RED ✗'
                      else:
                          status_color = test_status
                      
                      formatted_line = f"Task {index}: {task_description} - {status_color}"
                      formatted_lines.append(formatted_line)
              
              return '\n'.join(formatted_lines)

          # Read the JSON file
          with open('logs/kurtosis-outputs.json', 'r') as f:
              outputs = json.load(f)

          # If test_overview or failed_test_details exist in the original JSON
          original_json = json.loads(outputs.get('test_result_json', '{}'))
          
          # Format test details
          formatted_details = format_test_details(original_json.get('failed_test_details', ''))
          
          # Create a human-readable text file
          with open('logs/test-details-readable.txt', 'w') as f:
              f.write("Test Overview:\n")
              f.write(original_json.get('test_overview', 'No overview available') + "\n\n")
              f.write("Detailed Test Results:\n")
              f.write(formatted_details)
          
          # Print to console for immediate visibility
          print(open('logs/test-details-readable.txt', 'r').read())
          EOF

      - name: Save Kurtosis test logs
        if: steps.kurtosis-test.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: human-readable-test-details
          path: logs/test-details-readable.txt
          retention-days: 14

      - name: Check test result
        if: steps.kurtosis-test.outcome != 'success'
        run: exit 1